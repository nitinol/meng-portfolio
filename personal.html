<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Menguhan - Living Atmosphere</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;400;500&display=swap" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            color: white;
            /* Default, controlled by JS */
            background: #000;
            transition: color 1s ease;
        }

        /* LAYERS */
        #skyLayer,
        #starCanvas,
        #weatherOverlay,
        #flashOverlay,
        #weatherCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #skyLayer {
            z-index: 0;
            transition: background 5s ease;
        }

        #starCanvas {
            z-index: 1;
            transition: opacity 5s ease;
        }

        #weatherOverlay {
            z-index: 2;
            transition: background 2s ease;
        }

        #flashOverlay {
            z-index: 3;
            background: white;
            opacity: 0;
        }

        #weatherCanvas {
            z-index: 4;
        }

        /* TOP RIGHT PANEL (Just Degree) */
        .top-bar {
            position: absolute;
            top: 40px;
            right: 50px;
            z-index: 20;
            font-weight: 300;
            cursor: pointer;
            /* Clickable */
            user-select: none;
        }

        .mini-stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
            /* Larger, cleaner text */
            opacity: 0.9;
        }

        .weather-icon {
            font-size: 1.8rem;
        }

        .degree-text {
            font-weight: 200;
        }

        /* CENTER MESSAGE */
        .center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            opacity: 0;
            animation: fadeIn 2s forwards 0.5s;
        }

        .title {
            font-size: 3rem;
            font-weight: 100;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 0.9rem;
            font-weight: 400;
            letter-spacing: 2px;
            opacity: 0.8;
            margin-top: 5px;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <!-- SCENE LAYERS -->
    <div id="skyLayer"></div>
    <canvas id="starCanvas"></canvas>
    <div id="weatherOverlay"></div>
    <div id="flashOverlay"></div>
    <canvas id="weatherCanvas"></canvas>

    <!-- TOP RIGHT INFO -->
    <div class="top-bar">
        <!-- Weather Text Only -->
        <div class="mini-stat" id="weatherBox">
            <span id="wIcon" class="weather-icon"></span>
            <span id="wTemp" class="degree-text">--¬∞</span>
        </div>
    </div>

    <!-- CENTER TEXT -->
    <div class="center-message">
        <div class="title">Menguhan</div>
        <div class="subtitle">Under Development</div>
    </div>

    <script>
        // ==========================================
        //  THE ENGINE
        // ==========================================
        const STATE = {
            lat: 40.18, lon: 29.06,
            loaded: false,
            temp: 0,
            weatherCode: 0,
            windSpeed: 0,
            humidity: 0,
            isDay: 1,
            sunrise: 7,
            sunset: 19,
            timezone: "UTC",
            thunderTimer: 0,
            debug: false
        };

        const ELS = {
            sky: document.getElementById('skyLayer'),
            stars: document.getElementById('starCanvas'),
            overlay: document.getElementById('weatherOverlay'),
            flash: document.getElementById('flashOverlay'),
            icon: document.getElementById('wIcon'),
            temp: document.getElementById('wTemp'),
            canvas: document.getElementById('weatherCanvas'),
            topBar: document.querySelector('.top-bar'),
            centerTitle: document.querySelector('.title')
        };
        const CTX = ELS.canvas.getContext('2d');
        const STAR_CTX = ELS.stars.getContext('2d');

        // Star & Comet Data
        let starsData = [];
        let comets = [];

        function init() {
            resize();
            window.onresize = resize;

            // Init Stars (Dynamic)
            initStars();

            ELS.topBar.onclick = () => {
                STATE.debug = !STATE.debug;
                if (STATE.debug) {
                    ELS.centerTitle.textContent = `${STATE.lat.toFixed(2)}, ${STATE.lon.toFixed(2)} [${STATE.timezone}]`;
                    ELS.centerTitle.style.fontSize = "1rem";
                } else {
                    ELS.centerTitle.textContent = "Menguhan";
                    ELS.centerTitle.style.fontSize = "3rem";
                }
            };

            setInterval(tickClock, 1000);
            setInterval(fetchData, 60000);
            requestAnimationFrame(renderLoop);

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    STATE.lat = pos.coords.latitude;
                    STATE.lon = pos.coords.longitude;
                    fetchData();
                }, () => fetchData(), { enableHighAccuracy: true });
            } else fetchData();
        }

        function resize() {
            ELS.canvas.width = window.innerWidth;
            ELS.canvas.height = window.innerHeight;
            ELS.stars.width = window.innerWidth;
            ELS.stars.height = window.innerHeight;
            initStars();
        }

        function initStars() {
            starsData = [];
            for (let i = 0; i < 400; i++) {
                starsData.push({
                    x: Math.random() * ELS.stars.width,
                    y: Math.random() * ELS.stars.height * 0.8,
                    size: Math.random() * 1.5,
                    alpha: Math.random() * 0.8 + 0.2,
                    tSpeed: Math.random() * 0.05 + 0.005,
                    tPhase: Math.random() * Math.PI * 2
                });
            }
        }

        async function fetchData() {
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${STATE.lat}&longitude=${STATE.lon}&current=temperature_2m,relative_humidity_2m,is_day,weather_code,wind_speed_10m&daily=sunrise,sunset&timezone=auto`;
                const res = await fetch(url);
                const data = await res.json();

                STATE.temp = Math.round(data.current.temperature_2m);
                STATE.humidity = data.current.relative_humidity_2m;
                STATE.isDay = data.current.is_day;
                STATE.weatherCode = data.current.weather_code;
                STATE.windSpeed = data.current.wind_speed_10m;
                STATE.timezone = data.timezone; // STORE IT

                if (data.daily) {
                    const getHour = (iso) => {
                        const d = new Date(iso);
                        return d.getHours() + (d.getMinutes() / 60);
                    };
                    STATE.sunrise = getHour(data.daily.sunrise[0]);
                    STATE.sunset = getHour(data.daily.sunset[0]);
                }

                STATE.loaded = true;
                tickClock();
            } catch (e) { console.error("API Error", e); }
        }

        // Helper: Get Decimal Hour for specific Timezone
        function getRemoteTime(tz) {
            try {
                const s = new Date().toLocaleString("en-US", { timeZone: tz });
                const d = new Date(s);
                return d.getHours() + (d.getMinutes() / 60);
            } catch (e) {
                const d = new Date();
                return d.getHours() + (d.getMinutes() / 60);
            }
        }

        function tickClock() {
            if (STATE.loaded) {
                ELS.temp.textContent = `${STATE.temp}¬∞`;
                const cond = getWeatherCondition(STATE.weatherCode);
                ELS.icon.textContent = STATE.isDay ? cond.icon : cond.iconNight;
            } else {
                ELS.icon.textContent = "‚Ä¢";
            }

            // --- CRITICAL FIX: USE REMOTE TIME ---
            const time = getRemoteTime(STATE.timezone);
            const sunR = STATE.sunrise;
            const sunS = STATE.sunset;

            const C_DEEP_NIGHT = [[222, 47, 11], [222, 47, 15]];
            const C_PRE_DAWN = [[222, 47, 15], [222, 47, 20]];
            const C_DAWN = [[210, 80, 50], [25, 90, 60]];
            const C_DAY = [[200, 90, 50], [195, 90, 80]];
            const C_SUNSET = [[260, 60, 30], [340, 70, 60]];
            const C_TWILIGHT = [[240, 50, 20], [240, 50, 10]];

            const keys = [
                { t: 0, c: C_DEEP_NIGHT },
                { t: sunR - 1.5, c: C_PRE_DAWN },
                { t: sunR, c: C_DAWN },
                { t: sunR + 1.5, c: C_DAY },
                { t: sunS - 1.5, c: C_DAY },
                { t: sunS, c: C_SUNSET },
                { t: sunS + 1.0, c: C_TWILIGHT },
                { t: 24, c: C_DEEP_NIGHT }
            ];

            let start = keys[0];
            let end = keys[keys.length - 1];

            for (let i = 0; i < keys.length - 1; i++) {
                if (time >= keys[i].t && time < keys[i + 1].t) {
                    start = keys[i]; end = keys[i + 1]; break;
                }
            }

            let p = 0;
            if (end.t !== start.t) p = (time - start.t) / (end.t - start.t);
            p = Math.max(0, Math.min(1, p));

            const top = lerpColorHSL(start.c[0], end.c[0], p);
            const bot = lerpColorHSL(start.c[1], end.c[1], p);

            const mod = getWeatherModifier(STATE.weatherCode);

            const topL = top[2] * mod.light;
            const topFinal = `hsl(${top[0]}, ${top[1] * mod.sat}%, ${topL}%)`;
            const botFinal = `hsl(${bot[0]}, ${bot[1] * mod.sat}%, ${bot[2] * mod.light}%)`;

            ELS.sky.style.background = `linear-gradient(to bottom, ${topFinal}, ${botFinal})`;
            ELS.overlay.style.background = mod.overlay;

            if (topL > 60) document.body.style.color = 'rgba(0,0,0,0.8)';
            else document.body.style.color = 'white';

            // --- STAR OPACITY (Remote Time Logic) ---
            let starOp = 0;
            const isDark = (time > (sunS + 0.5)) || (time < (sunR - 1.0));
            if (isDark) starOp = 1;

            if (time >= sunS && time < sunS + 0.5) starOp = (time - sunS) / 0.5;
            if (time >= sunR - 1 && time < sunR) starOp = 1 - (time - (sunR - 1));

            if (STATE.weatherCode > 2) starOp = 0;
            else if (STATE.weatherCode === 2) starOp *= 0.5;

            ELS.stars.style.opacity = starOp;
        }

        // ==========================
        // 4. ANIMATION LOOP (Particles + Stars)
        // ==========================
        function renderLoop() {
            // Weather
            CTX.clearRect(0, 0, ELS.canvas.width, ELS.canvas.height);

            // Stars & Comets (Clear for animation)
            STAR_CTX.clearRect(0, 0, ELS.stars.width, ELS.stars.height);

            if (!STATE.loaded) { requestAnimationFrame(renderLoop); return; }

            // --- STARS LOGIC ---
            // Only draw/animate if visible
            const starOp = parseFloat(ELS.stars.style.opacity || 0);

            if (starOp > 0) {
                STAR_CTX.fillStyle = "white";
                starsData.forEach(s => {
                    // Twinkle
                    s.tPhase += s.tSpeed;
                    const twinkle = Math.sin(s.tPhase) * 0.5; // +/- 0.5 opacity
                    let a = s.alpha + (twinkle * 0.3);
                    if (a < 0) a = 0; if (a > 1) a = 1;

                    // Drift (Left)
                    s.x -= 0.05;
                    if (s.x < 0) s.x = ELS.stars.width;

                    STAR_CTX.globalAlpha = a;
                    STAR_CTX.beginPath();
                    STAR_CTX.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    STAR_CTX.fill();
                });

                // --- COMET LOGIC ---
                // Random spawn chance (rare)
                if (Math.random() < 0.001) {
                    comets.push({
                        x: Math.random() < 0.5 ? ELS.stars.width : 0, // From side
                        y: Math.random() * ELS.stars.height * 0.5,
                        dx: (Math.random() > 0.5 ? -1 : 1) * (4 + Math.random() * 4), // Fast
                        dy: 1 + Math.random(), // Downwards slightly
                        len: 50 + Math.random() * 100,
                        life: 1.0
                    });
                }

                // Draw Comets
                for (let i = 0; i < comets.length; i++) {
                    let c = comets[i];
                    c.x += c.dx;
                    c.y += c.dy;
                    c.life -= 0.01;

                    if (c.life <= 0 || c.x < -200 || c.x > ELS.stars.width + 200) {
                        comets.splice(i, 1); i--; continue;
                    }

                    // Draw Head
                    const grad = STAR_CTX.createLinearGradient(c.x, c.y, c.x - c.dx * 30, c.y - c.dy * 30);
                    grad.addColorStop(0, `rgba(255,255,255,${c.life})`);
                    grad.addColorStop(1, `rgba(255,255,255,0)`);

                    STAR_CTX.strokeStyle = grad;
                    STAR_CTX.lineWidth = 2;
                    STAR_CTX.beginPath();
                    STAR_CTX.moveTo(c.x, c.y);
                    STAR_CTX.lineTo(c.x - c.dx * 20, c.y - c.dy * 20); // Trail
                    STAR_CTX.stroke();
                }
            }

            // --- WEATHER PARTICLES LOGIC ---
            const cfg = getParticleConfig(STATE.weatherCode);

            if (cfg.thunder && Math.random() < 0.005) {
                ELS.flash.style.opacity = 0.8;
                setTimeout(() => ELS.flash.style.opacity = 0, 100);
            }

            if (cfg.type !== 'none' && particles.length < cfg.count) {
                particles.push(createParticle(cfg));
            }

            CTX.fillStyle = 'rgba(255,255,255,0.6)';
            CTX.strokeStyle = 'rgba(255,255,255,0.4)';
            CTX.lineWidth = 1;

            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                p.y += p.dy;
                p.x += p.dx + (STATE.windSpeed * 0.2);

                if (p.type === 'rain') {
                    CTX.beginPath(); CTX.moveTo(p.x, p.y);
                    CTX.lineTo(p.x + (STATE.windSpeed * 0.2), p.y + p.len); CTX.stroke();
                } else if (p.type === 'snow') {
                    p.x += Math.sin(p.y * 0.01) * 0.5;
                    CTX.beginPath(); CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2); CTX.fill();
                } else if (p.type === 'fog') {
                    CTX.fillStyle = `rgba(255,255,255, ${0.05})`;
                    CTX.beginPath(); CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2); CTX.fill();
                    CTX.fillStyle = 'rgba(255,255,255,0.6)';
                }

                if (p.y > ELS.canvas.height + 20 || p.x > ELS.canvas.width + 20) {
                    particles.splice(i, 1); i--;
                }
            }
            requestAnimationFrame(renderLoop);
        }

        function createParticle(cfg) {
            return {
                x: Math.random() * ELS.canvas.width,
                y: -20,
                dx: (Math.random() - 0.5) * 0.5,
                dy: cfg.speed + (Math.random() * 2),
                size: cfg.size + Math.random(),
                len: cfg.len + (Math.random() * 5),
                type: cfg.type
            };
        }

        // Helpers
        function pad(n) { return n < 10 ? '0' + n : n; }
        function lerpColorHSL(a, b, p) {
            return [a[0] + (b[0] - a[0]) * p, a[1] + (b[1] - a[1]) * p, a[2] + (b[2] - a[2]) * p];
        }

        function getWeatherModifier(code) {
            let sat = 1.0, light = 1.0, overlay = 'transparent';
            if (code >= 95) { sat = 0.4; light = 0.3; overlay = 'rgba(20,0,30,0.3)'; }
            else if (code >= 60 || code >= 80) { sat = 0.5; light = 0.7; overlay = 'rgba(0,0,10,0.2)'; }
            else if (code >= 70) { sat = 0.2; light = 1.1; overlay = 'rgba(255,255,255,0.1)'; }
            else if (code >= 45) { sat = 0.1; light = 0.8; overlay = 'rgba(200,200,200,0.2)'; }
            else if (code >= 3) { sat = 0.6; light = 0.9; }
            return { sat, light, overlay };
        }

        function getParticleConfig(code) {
            let c = { type: 'none', count: 0, speed: 0, size: 0, len: 0, thunder: false };
            if (code >= 95) c = { type: 'rain', count: 300, speed: 15, size: 1, len: 20, thunder: true };
            else if (code >= 70 && code <= 77) {
                c = { type: 'snow', count: 200, speed: 1, size: 2, len: 0, thunder: false };
                if (code === 71) c.count = 100; if (code === 75) { c.count = 400; c.speed = 3; }
            } else if ((code >= 51 && code <= 67) || (code >= 80)) {
                c = { type: 'rain', count: 200, speed: 10, size: 1, len: 15, thunder: false };
                if (code <= 55) { c.count = 50; c.speed = 5; }
                if (code >= 65) { c.count = 400; c.speed = 18; }
            } else if (code === 45 || code === 48) {
                c = { type: 'fog', count: 20, speed: 0.2, size: 50, len: 0, thunder: false };
            }
            return c;
        }

        function getWeatherCondition(code) {
            const map = {
                0: { l: "Clear Sky", i: "‚òÄÔ∏è", n: "üåô" },
                1: { l: "Mainly Clear", i: "üå§Ô∏è", n: "üåô" },
                2: { l: "Partly Cloudy", i: "‚õÖ", n: "‚òÅÔ∏è" },
                3: { l: "Overcast", i: "‚òÅÔ∏è", n: "‚òÅÔ∏è" },
                45: { l: "Fog", i: "üå´Ô∏è", n: "üå´Ô∏è" }, 48: { l: "Rime Fog", i: "üå´Ô∏è", n: "üå´Ô∏è" },
                51: { l: "Light Drizzle", i: "üå¶Ô∏è", n: "üåßÔ∏è" }, 53: { l: "Drizzle", i: "üå¶Ô∏è", n: "üåßÔ∏è" }, 55: { l: "Heavy Drizzle", i: "üåßÔ∏è", n: "üåßÔ∏è" },
                61: { l: "Slight Rain", i: "üå¶Ô∏è", n: "üåßÔ∏è" }, 63: { l: "Rain", i: "üåßÔ∏è", n: "üåßÔ∏è" }, 65: { l: "Heavy Rain", i: "üåßÔ∏è", n: "üåßÔ∏è" },
                71: { l: "Light Snow", i: "üå®Ô∏è", n: "üå®Ô∏è" }, 73: { l: "Snow", i: "üå®Ô∏è", n: "üå®Ô∏è" }, 75: { l: "Heavy Snow", i: "‚ùÑÔ∏è", n: "‚ùÑÔ∏è" },
                77: { l: "Snow Grains", i: "üå®Ô∏è", n: "üå®Ô∏è" },
                80: { l: "Showers", i: "üå¶Ô∏è", n: "üåßÔ∏è" }, 81: { l: "Heavy Showers", i: "üåßÔ∏è", n: "üåßÔ∏è" }, 82: { l: "Violent Showers", i: "‚õàÔ∏è", n: "‚õàÔ∏è" },
                95: { l: "Thunderstorm", i: "‚õàÔ∏è", n: "‚ö°" }, 96: { l: "Thunderstorm & Hail", i: "‚õàÔ∏è", n: "‚ö°" }, 99: { l: "Heavy Hail Storm", i: "‚õàÔ∏è", n: "‚ö°" }
            };
            return map[code] || { l: "Unknown", i: "?", n: "?" };
        }

        init();
    </script>
</body>

</html>