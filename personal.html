<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Menguhan - Living Atmosphere</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;400;500&display=swap" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            color: white;
            background: #000;
            transition: color 1s ease;
        }

        #skyLayer,
        #starCanvas,
        #weatherOverlay,
        #flashOverlay,
        #weatherCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }

        #skyLayer {
            z-index: 0;
            transition: background 5s ease;
        }

        #starCanvas {
            z-index: 1;
            transition: opacity 5s ease;
        }

        #weatherOverlay {
            z-index: 2;
            transition: background 2s ease;
        }

        #flashOverlay {
            z-index: 3;
            background: white;
            opacity: 0;
        }

        #weatherCanvas {
            z-index: 4;
        }

        .top-bar {
            position: fixed;
            top: 40px;
            right: 50px;
            z-index: 20;
            font-weight: 300;
            cursor: pointer;
            user-select: none;
        }

        .mini-stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.5rem;
            opacity: 0.9;
        }

        .weather-icon {
            font-size: 1.8rem;
        }

        .degree-text {
            font-weight: 200;
        }

        .center-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            opacity: 0;
            animation: fadeIn 2s forwards 0.5s;
        }

        .title {
            font-size: 3rem;
            font-weight: 100;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-transform: uppercase;
            transition: font-size 0.3s;
        }

        .subtitle {
            font-size: 0.9rem;
            font-weight: 400;
            letter-spacing: 2px;
            opacity: 0.8;
            margin-top: 5px;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div id="skyLayer"></div>
    <canvas id="starCanvas"></canvas>
    <div id="weatherOverlay"></div>
    <div id="flashOverlay"></div>
    <canvas id="weatherCanvas"></canvas>

    <div class="top-bar">
        <div class="mini-stat" id="weatherBox">
            <span id="wIcon" class="weather-icon"></span>
            <span id="wTemp" class="degree-text">--Â°</span>
        </div>
    </div>

    <div class="center-message">
        <div class="title">Menguhan</div>
        <div class="subtitle">Under Development</div>
    </div>

    <script>
        // ==========================================
        //  LIVING ATMOSPHERE ENGINE v2.0
        //  Fixed: Location, Canvas Scaling, Particles
        // ==========================================

        const STATE = {
            lat: null,
            lon: null,
            loaded: false,
            temp: 0,
            weatherCode: 0,
            windSpeed: 0,
            humidity: 0,
            isDay: 1,
            sunrise: 7,
            sunset: 19,
            timezone: "UTC",
            debug: false,
            locationSource: "pending"
        };

        const ELS = {
            sky: document.getElementById('skyLayer'),
            stars: document.getElementById('starCanvas'),
            overlay: document.getElementById('weatherOverlay'),
            flash: document.getElementById('flashOverlay'),
            icon: document.getElementById('wIcon'),
            temp: document.getElementById('wTemp'),
            canvas: document.getElementById('weatherCanvas'),
            topBar: document.querySelector('.top-bar'),
            centerTitle: document.querySelector('.title')
        };

        const CTX = ELS.canvas.getContext('2d');
        const STAR_CTX = ELS.stars.getContext('2d');

        // FIX: Declare particles array
        let particles = [];
        let starsData = [];
        let comets = [];

        // ==========================================
        //  INITIALIZATION
        // ==========================================
        async function init() {
            console.log("[Engine] Initializing...");

            setupCanvas();
            window.addEventListener('resize', setupCanvas);

            initStars();

            ELS.topBar.onclick = toggleDebug;

            // Start loops
            setInterval(tickClock, 1000);
            setInterval(fetchWeather, 60000);
            requestAnimationFrame(renderLoop);

            // Get location (IP-based first, then try GPS)
            await getLocation();
        }

        // FIX: Proper canvas scaling for zoom/devicePixelRatio
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;

            // Weather canvas
            ELS.canvas.width = w * dpr;
            ELS.canvas.height = h * dpr;
            ELS.canvas.style.width = w + 'px';
            ELS.canvas.style.height = h + 'px';
            CTX.scale(dpr, dpr);

            // Star canvas
            ELS.stars.width = w * dpr;
            ELS.stars.height = h * dpr;
            ELS.stars.style.width = w + 'px';
            ELS.stars.style.height = h + 'px';
            STAR_CTX.scale(dpr, dpr);

            // Re-init stars with new dimensions
            initStars();

            console.log(`[Canvas] Resized to ${w}x${h} (DPR: ${dpr})`);
        }

        function initStars() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            starsData = [];
            for (let i = 0; i < 400; i++) {
                starsData.push({
                    x: Math.random() * w,
                    y: Math.random() * h * 0.8,
                    size: Math.random() * 1.5 + 0.5,
                    alpha: Math.random() * 0.8 + 0.2,
                    tSpeed: Math.random() * 0.03 + 0.005,
                    tPhase: Math.random() * Math.PI * 2
                });
            }
        }

        // ==========================================
        //  LOCATION (IP-based, no permission needed)
        // ==========================================
        async function getLocation() {
            console.log("[Location] Getting location...");

            // Method 1: IP-based (always works, no permission)
            try {
                const res = await fetch('https://ipapi.co/json/');
                const data = await res.json();
                if (data.latitude && data.longitude) {
                    STATE.lat = data.latitude;
                    STATE.lon = data.longitude;
                    STATE.locationSource = "IP";
                    console.log(`[Location] IP-based: ${STATE.lat}, ${STATE.lon}`);
                    await fetchWeather();
                    return;
                }
            } catch (e) {
                console.warn("[Location] IP lookup failed:", e);
            }

            // Method 2: Try browser geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    async (pos) => {
                        STATE.lat = pos.coords.latitude;
                        STATE.lon = pos.coords.longitude;
                        STATE.locationSource = "GPS";
                        console.log(`[Location] GPS: ${STATE.lat}, ${STATE.lon}`);
                        await fetchWeather();
                    },
                    async (err) => {
                        console.warn("[Location] GPS failed:", err.message);
                        // Fallback to default
                        if (!STATE.lat) {
                            STATE.lat = 40.18;
                            STATE.lon = 29.06;
                            STATE.locationSource = "DEFAULT";
                            await fetchWeather();
                        }
                    },
                    { enableHighAccuracy: false, timeout: 5000 }
                );
            } else {
                // No geolocation support, use default
                STATE.lat = 40.18;
                STATE.lon = 29.06;
                STATE.locationSource = "DEFAULT";
                await fetchWeather();
            }
        }

        // ==========================================
        //  WEATHER API
        // ==========================================
        async function fetchWeather() {
            if (!STATE.lat || !STATE.lon) return;

            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${STATE.lat}&longitude=${STATE.lon}&current=temperature_2m,relative_humidity_2m,is_day,weather_code,wind_speed_10m&daily=sunrise,sunset&timezone=auto`;
                console.log("[Weather] Fetching:", url);

                const res = await fetch(url);
                const data = await res.json();

                STATE.temp = Math.round(data.current.temperature_2m);
                STATE.humidity = data.current.relative_humidity_2m;
                STATE.isDay = data.current.is_day;
                STATE.weatherCode = data.current.weather_code;
                STATE.windSpeed = data.current.wind_speed_10m;
                STATE.timezone = data.timezone;

                if (data.daily) {
                    STATE.sunrise = parseTimeToHours(data.daily.sunrise[0]);
                    STATE.sunset = parseTimeToHours(data.daily.sunset[0]);
                }

                STATE.loaded = true;
                console.log(`[Weather] Loaded: ${STATE.temp}Â°, Code: ${STATE.weatherCode}, TZ: ${STATE.timezone}`);

                tickClock();
            } catch (e) {
                console.error("[Weather] API Error:", e);
            }
        }

        function parseTimeToHours(isoString) {
            const d = new Date(isoString);
            return d.getHours() + (d.getMinutes() / 60);
        }

        // ==========================================
        //  TIME & SKY COLOR
        // ==========================================
        function getRemoteTime(tz) {
            try {
                const str = new Date().toLocaleString("en-US", { timeZone: tz });
                const d = new Date(str);
                return d.getHours() + (d.getMinutes() / 60);
            } catch (e) {
                const d = new Date();
                return d.getHours() + (d.getMinutes() / 60);
            }
        }

        function tickClock() {
            if (!STATE.loaded) return;

            // Update UI
            ELS.temp.textContent = `${STATE.temp}Â°`;
            const cond = getWeatherCondition(STATE.weatherCode);
            ELS.icon.textContent = STATE.isDay ? cond.icon : cond.iconNight;

            // Calculate sky color based on REMOTE time
            const time = getRemoteTime(STATE.timezone);
            const sunR = STATE.sunrise;
            const sunS = STATE.sunset;

            // Color keyframes
            const C_DEEP_NIGHT = [[222, 47, 11], [222, 47, 15]];
            const C_PRE_DAWN = [[222, 47, 15], [222, 47, 20]];
            const C_DAWN = [[210, 80, 50], [25, 90, 60]];
            const C_DAY = [[200, 90, 50], [195, 90, 80]];
            const C_SUNSET = [[260, 60, 30], [340, 70, 60]];
            const C_TWILIGHT = [[240, 50, 20], [240, 50, 10]];

            const keys = [
                { t: 0, c: C_DEEP_NIGHT },
                { t: sunR - 1.5, c: C_PRE_DAWN },
                { t: sunR, c: C_DAWN },
                { t: sunR + 1.5, c: C_DAY },
                { t: sunS - 1.5, c: C_DAY },
                { t: sunS, c: C_SUNSET },
                { t: sunS + 1.0, c: C_TWILIGHT },
                { t: 24, c: C_DEEP_NIGHT }
            ];

            let start = keys[0];
            let end = keys[keys.length - 1];

            for (let i = 0; i < keys.length - 1; i++) {
                if (time >= keys[i].t && time < keys[i + 1].t) {
                    start = keys[i];
                    end = keys[i + 1];
                    break;
                }
            }

            let p = (end.t !== start.t) ? (time - start.t) / (end.t - start.t) : 0;
            p = Math.max(0, Math.min(1, p));

            const top = lerpColorHSL(start.c[0], end.c[0], p);
            const bot = lerpColorHSL(start.c[1], end.c[1], p);

            const mod = getWeatherModifier(STATE.weatherCode);

            const topL = top[2] * mod.light;
            const topFinal = `hsl(${top[0]}, ${top[1] * mod.sat}%, ${topL}%)`;
            const botFinal = `hsl(${bot[0]}, ${bot[1] * mod.sat}%, ${bot[2] * mod.light}%)`;

            ELS.sky.style.background = `linear-gradient(to bottom, ${topFinal}, ${botFinal})`;
            ELS.overlay.style.background = mod.overlay;

            // Text contrast
            document.body.style.color = topL > 60 ? 'rgba(0,0,0,0.8)' : 'white';

            // Star visibility
            let starOp = 0;
            const isDark = (time > (sunS + 0.5)) || (time < (sunR - 1.0));
            if (isDark) starOp = 1;

            if (time >= sunS && time < sunS + 0.5) starOp = (time - sunS) / 0.5;
            if (time >= sunR - 1 && time < sunR) starOp = 1 - (time - (sunR - 1));

            if (STATE.weatherCode > 2) starOp = 0;
            else if (STATE.weatherCode === 2) starOp *= 0.5;

            ELS.stars.style.opacity = starOp;
        }

        // ==========================================
        //  DEBUG TOGGLE
        // ==========================================
        function toggleDebug() {
            STATE.debug = !STATE.debug;
            if (STATE.debug) {
                const time = getRemoteTime(STATE.timezone);
                ELS.centerTitle.textContent = `${STATE.lat?.toFixed(2) || '?'}, ${STATE.lon?.toFixed(2) || '?'} [${STATE.locationSource}]\n${STATE.timezone} | ${time.toFixed(2)}h`;
                ELS.centerTitle.style.fontSize = "0.9rem";
                ELS.centerTitle.style.whiteSpace = "pre-line";
            } else {
                ELS.centerTitle.textContent = "Menguhan";
                ELS.centerTitle.style.fontSize = "3rem";
                ELS.centerTitle.style.whiteSpace = "normal";
            }
        }

        // ==========================================
        //  RENDER LOOP
        // ==========================================
        function renderLoop() {
            const w = window.innerWidth;
            const h = window.innerHeight;

            // Clear canvases
            CTX.clearRect(0, 0, w, h);
            STAR_CTX.clearRect(0, 0, w, h);

            if (!STATE.loaded) {
                requestAnimationFrame(renderLoop);
                return;
            }

            // Stars
            const starOp = parseFloat(ELS.stars.style.opacity || 0);
            if (starOp > 0) {
                STAR_CTX.fillStyle = "white";

                starsData.forEach(s => {
                    s.tPhase += s.tSpeed;
                    const twinkle = Math.sin(s.tPhase) * 0.3;
                    let a = s.alpha + twinkle;
                    a = Math.max(0.1, Math.min(1, a));

                    s.x -= 0.03;
                    if (s.x < 0) s.x = w;

                    STAR_CTX.globalAlpha = a;
                    STAR_CTX.beginPath();
                    STAR_CTX.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    STAR_CTX.fill();
                });

                // Comets
                if (Math.random() < 0.0008) {
                    comets.push({
                        x: Math.random() < 0.5 ? w : 0,
                        y: Math.random() * h * 0.5,
                        dx: (Math.random() > 0.5 ? -1 : 1) * (5 + Math.random() * 5),
                        dy: 1.5 + Math.random(),
                        life: 1.0
                    });
                }

                for (let i = comets.length - 1; i >= 0; i--) {
                    let c = comets[i];
                    c.x += c.dx;
                    c.y += c.dy;
                    c.life -= 0.012;

                    if (c.life <= 0 || c.x < -100 || c.x > w + 100) {
                        comets.splice(i, 1);
                        continue;
                    }

                    const grad = STAR_CTX.createLinearGradient(c.x, c.y, c.x - c.dx * 25, c.y - c.dy * 25);
                    grad.addColorStop(0, `rgba(255,255,255,${c.life})`);
                    grad.addColorStop(1, `rgba(255,255,255,0)`);

                    STAR_CTX.strokeStyle = grad;
                    STAR_CTX.lineWidth = 2;
                    STAR_CTX.globalAlpha = 1;
                    STAR_CTX.beginPath();
                    STAR_CTX.moveTo(c.x, c.y);
                    STAR_CTX.lineTo(c.x - c.dx * 20, c.y - c.dy * 20);
                    STAR_CTX.stroke();
                }
            }

            // Weather particles
            const cfg = getParticleConfig(STATE.weatherCode);

            if (cfg.thunder && Math.random() < 0.004) {
                ELS.flash.style.opacity = 0.7;
                setTimeout(() => ELS.flash.style.opacity = 0, 80);
            }

            while (cfg.type !== 'none' && particles.length < cfg.count) {
                particles.push(createParticle(cfg, w, h));
            }

            CTX.fillStyle = 'rgba(255,255,255,0.6)';
            CTX.strokeStyle = 'rgba(255,255,255,0.4)';
            CTX.lineWidth = 1;

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.y += p.dy;
                p.x += p.dx + (STATE.windSpeed * 0.15);

                if (p.type === 'rain') {
                    CTX.beginPath();
                    CTX.moveTo(p.x, p.y);
                    CTX.lineTo(p.x + (STATE.windSpeed * 0.15), p.y + p.len);
                    CTX.stroke();
                } else if (p.type === 'snow') {
                    p.x += Math.sin(p.y * 0.01) * 0.4;
                    CTX.globalAlpha = 0.8;
                    CTX.beginPath();
                    CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    CTX.fill();
                    CTX.globalAlpha = 1;
                } else if (p.type === 'fog') {
                    CTX.globalAlpha = 0.03;
                    CTX.beginPath();
                    CTX.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    CTX.fill();
                    CTX.globalAlpha = 1;
                }

                if (p.y > h + 30 || p.x > w + 30 || p.x < -30) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(renderLoop);
        }

        function createParticle(cfg, w, h) {
            return {
                x: Math.random() * w,
                y: -20,
                dx: (Math.random() - 0.5) * 0.4,
                dy: cfg.speed + (Math.random() * 2),
                size: cfg.size + Math.random(),
                len: cfg.len + (Math.random() * 5),
                type: cfg.type
            };
        }

        // ==========================================
        //  HELPERS
        // ==========================================
        function lerpColorHSL(a, b, p) {
            return [a[0] + (b[0] - a[0]) * p, a[1] + (b[1] - a[1]) * p, a[2] + (b[2] - a[2]) * p];
        }

        function getWeatherModifier(code) {
            let sat = 1.0, light = 1.0, overlay = 'transparent';
            if (code >= 95) { sat = 0.4; light = 0.3; overlay = 'rgba(20,0,30,0.3)'; }
            else if (code >= 80) { sat = 0.5; light = 0.6; overlay = 'rgba(0,0,20,0.25)'; }
            else if (code >= 70) { sat = 0.3; light = 1.0; overlay = 'rgba(255,255,255,0.1)'; }
            else if (code >= 60) { sat = 0.5; light = 0.7; overlay = 'rgba(0,0,10,0.2)'; }
            else if (code >= 45) { sat = 0.2; light = 0.85; overlay = 'rgba(180,180,180,0.2)'; }
            else if (code >= 3) { sat = 0.7; light = 0.9; }
            return { sat, light, overlay };
        }

        function getParticleConfig(code) {
            if (code >= 95) return { type: 'rain', count: 350, speed: 16, size: 1, len: 22, thunder: true };
            if (code >= 80) return { type: 'rain', count: 250, speed: 12, size: 1, len: 18, thunder: false };
            if (code >= 70 && code <= 77) {
                const intensity = code === 75 ? 400 : code === 71 ? 100 : 200;
                return { type: 'snow', count: intensity, speed: 1.5, size: 2.5, len: 0, thunder: false };
            }
            if (code >= 60) return { type: 'rain', count: 200, speed: 10, size: 1, len: 15, thunder: false };
            if (code >= 51 && code <= 55) return { type: 'rain', count: 80, speed: 6, size: 1, len: 10, thunder: false };
            if (code === 45 || code === 48) return { type: 'fog', count: 25, speed: 0.15, size: 60, len: 0, thunder: false };
            return { type: 'none', count: 0, speed: 0, size: 0, len: 0, thunder: false };
        }

        function getWeatherCondition(code) {
            const map = {
                0: { l: "Clear", icon: "â˜€ï¸", iconNight: "ðŸŒ™" },
                1: { l: "Mainly Clear", icon: "ðŸŒ¤ï¸", iconNight: "ðŸŒ™" },
                2: { l: "Partly Cloudy", icon: "â›…", iconNight: "â˜ï¸" },
                3: { l: "Overcast", icon: "â˜ï¸", iconNight: "â˜ï¸" },
                45: { l: "Fog", icon: "ðŸŒ«ï¸", iconNight: "ðŸŒ«ï¸" },
                48: { l: "Rime Fog", icon: "ðŸŒ«ï¸", iconNight: "ðŸŒ«ï¸" },
                51: { l: "Light Drizzle", icon: "ðŸŒ¦ï¸", iconNight: "ðŸŒ§ï¸" },
                53: { l: "Drizzle", icon: "ðŸŒ¦ï¸", iconNight: "ðŸŒ§ï¸" },
                55: { l: "Heavy Drizzle", icon: "ðŸŒ§ï¸", iconNight: "ðŸŒ§ï¸" },
                61: { l: "Light Rain", icon: "ðŸŒ¦ï¸", iconNight: "ðŸŒ§ï¸" },
                63: { l: "Rain", icon: "ðŸŒ§ï¸", iconNight: "ðŸŒ§ï¸" },
                65: { l: "Heavy Rain", icon: "ðŸŒ§ï¸", iconNight: "ðŸŒ§ï¸" },
                71: { l: "Light Snow", icon: "ðŸŒ¨ï¸", iconNight: "ðŸŒ¨ï¸" },
                73: { l: "Snow", icon: "ðŸŒ¨ï¸", iconNight: "ðŸŒ¨ï¸" },
                75: { l: "Heavy Snow", icon: "â„ï¸", iconNight: "â„ï¸" },
                77: { l: "Snow Grains", icon: "ðŸŒ¨ï¸", iconNight: "ðŸŒ¨ï¸" },
                80: { l: "Showers", icon: "ðŸŒ¦ï¸", iconNight: "ðŸŒ§ï¸" },
                81: { l: "Heavy Showers", icon: "ðŸŒ§ï¸", iconNight: "ðŸŒ§ï¸" },
                82: { l: "Violent Showers", icon: "â›ˆï¸", iconNight: "â›ˆï¸" },
                95: { l: "Thunderstorm", icon: "â›ˆï¸", iconNight: "âš¡" },
                96: { l: "Thunderstorm & Hail", icon: "â›ˆï¸", iconNight: "âš¡" },
                99: { l: "Heavy Hail", icon: "â›ˆï¸", iconNight: "âš¡" }
            };
            return map[code] || { l: "Unknown", icon: "?", iconNight: "?" };
        }

        // Start
        init();
    </script>
</body>

</html>